#!/bin/env node

/**
 * @file
 * This script generates a TypeScript module that exports an object with relative image file paths
 * and dimensions for a given directory.
 * 
 * The script takes two parameters: the directory to scan for image files and the output file path
 * for the TypeScript module. It uses the image-size Node package to get the width and height of
 * each image file. It supports multiple image types defined as a global const. It writes a success
 * message to the console with the number of images processed.
 * 
 * The purpose of this script is to create a map of external images stored on different domains
 * (such as CDNs). This way, when displaying the image in HTML using the img tag, the width and
 * height of the image can be specified to avoid Content Layout Shift (CLS).
 * 
 * The script was created by Microsoft Bing chat mode, a conversational interface that can generate
 * code, among other things. See the README file for more information.
 */


// Importing the required modules
const fs = require('fs').promises;
const path = require('path');
const imageSize = require('image-size');
const yaml = require('js-yaml');

// Defining the global constant for image types
const IMAGE_TYPES = ['.jpg', '.png', '.gif', '.webp', '.svg'];

// Getting the directory and file path from command line arguments
const [directory, filePath] = process.argv.slice(2);

// Creating an empty map object to store image file paths and dimensions
const imageMap = {};

// A function to check if a file is an image based on its extension
function isImage(file) {
  return IMAGE_TYPES.includes(path.extname(file).toLowerCase());
}

// A function to get the relative path of a file based on the initial directory
function getRelativePath(file) {
  return path.relative(directory, file).replace(/\\/g, '/');
}

// A function to get the dimensions of an image using image-size package
async function getImageDimensions(file) {
  const buffer = await fs.readFile(file);
  const { width, height } = imageSize(buffer);
  return { width, height };
}

// A function to write the image map as a YAML file 
// (previously as a TypeScript module that exports it)
async function writeImageMap(map, file) {
  // const content =
  //   '// This file is generated by a Node.js script\n' +
  //   'export default ' +
  //   JSON.stringify(object, null, 2) +
  //   ';\n';
  // await fs.writeFile(file, content);

  // Write the map as a YAML file
  const yamlDoc = yaml.dump(map);
  fs.writeFile(file, yamlDoc);
}

// A function to find all image files in a directory and its subdirectories recursively
async function findImagesInDirectory(dir) {
  // Get all files and directories in the current directory
  const filesAndDirs = await fs.readdir(dir);

  // Loop through each item and check if it is a file or a directory
  for (let item of filesAndDirs) {
    // Get the absolute path of the item
    const itemPath = path.join(dir, item);

    // Check if it is a directory or a file using stat method
    const stat = await fs.stat(itemPath);

    if (stat.isDirectory()) {
      // If it is a directory, call this function recursively with its path
      await findImagesInDirectory(itemPath);
    } else if (stat.isFile() && isImage(item)) {
      // If it is a file and an image, get its relative path and dimensions and add them to the map
      const relativePath = getRelativePath(itemPath);
      const dimensions = await getImageDimensions(itemPath);
      imageMap[relativePath] = dimensions;
    }
  }
}

// The main function that runs the script logic
async function main() {
  try {
    // Find all images in the given directory and populate the map with their paths and dimensions
    await findImagesInDirectory(directory);

    // Write the map as YAML file
    // (previously as a TypeScript module that exports it to the given file path)
    await writeImageMap(imageMap, filePath);

    // Write a success message to console with number of images processed 
    console.log(`Successfully processed ${Object.keys(imageMap).length} images.`);
    
  } catch (error) {
    // Handle any errors by logging them to console 
    console.error(error.message);
    
  }
}

// Invoke main function 
main();